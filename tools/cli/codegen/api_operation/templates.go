package apioperation

import "strings"

const apiOperationContent = `${defineTemplates}
// This is an autogenerated file. DO NOT MODIFY 
package {{ .packageName }}

{{ if .imports }} {{ range $index, $import := .imports }}
import "{{ $import }}" {{ end }} {{ end }}

{{ if .input }} 
{{ if .input.additionalStructs }} {{ range $index, $additionalStruct := .input.additionalStructs }} 
{{ template "inputStructTemplate" $additionalStruct }} 
{{ end }} {{ end }}
{{ template "inputStructTemplate" .input }}
{{ end }}

{{ if .response }} 
{{ if .response.additionalStructs }} {{ range $index, $additionalStruct := .response.additionalStructs }} 
{{ template "responseStructTemplate" $additionalStruct }} 
{{ end }} {{ end }}
{{ template "responseStructTemplate" .response }}
{{ end }}

{{ if .documentation }} // {{ .name }} {{ .documentation.description }} {{ if .documentation.twilioDocsLink }} 
// See {{ .documentation.twilioDocsLink }} for more details {{ end }} 
// Context is defaulted to Background. See https://golang.org/pkg/context/#Background for more information {{ end }}
func (c Client) {{ .name }} ({{ if .input }}input *{{ .input.name }} {{ end }}) ({{ if .response }} *{{ .response.name }}, {{ end }} error) {
	return c.{{.name}}WithContext(context.Background() {{ if .input }}, input {{ end }})
}

{{ if .documentation }} // {{ .name }}WithContext {{ .documentation.description }} {{ if .documentation.twilioDocsLink }} 
// See {{ .documentation.twilioDocsLink }} for more details {{ end }} {{ end }}
func (c Client) {{ .name }}WithContext(context context.Context {{ if .input }}, input *{{ .input.name }} {{ end }}) ({{ if .response }} *{{ .response.name }}, {{ end }} error) {
	op := client.Operation{ ${overrideBaseURL}
		Method: http.Method{{ .http.method }},
		URI: "{{ .http.uri }}", ${addContentType} ${addPathParams}
	}

	{{ if .input }} if input == nil {
		input = &{{ .input.name }}{}
	} {{ end }}

	{{ if .response }} response := & {{ .response.name }} {} {{ end }}
	if err := c.client.Send(context, op, {{ if .input }} input {{ else }} nil {{ end }}, {{ if .response }} response {{ else }} nil {{ end }}); err != nil {
		return {{ if .response }} nil, {{ end }} err
	}
	return {{ if .response }} response, {{ end }} nil
}
`

const overrideBaseURL = `{{if .http.overrides}} 
OverrideBaseURL: utils.String(client.CreateBaseURL("{{ .http.overrides.subDomain }}", "{{ .http.overrides.apiVersion }}")),{{ end }}`

const addContentType = `{{ if .input }} 
ContentType: client.{{ .input.type }},{{ end }}`

const addPathParams = `{{ if .http.pathParams }} 
PathParams: map[string]string{ {{ range $index, $pathParam := .http.pathParams }}
	"{{ $pathParam.name }}": {{ if eq $pathParam.value.onService true }} {{ if eq $pathParam.value.type "int" }} strconv.Itoa(c.{{ $pathParam.value.property }}) {{ else }} c.{{ $pathParam.value.property }} {{ end }}, {{ end }} {{ end }}
},{{ end }}`

const inputTags = "`{{ if and $property.validation $property.validation.ignore }}{{ else }}{{ if and (ne $property.type \"bool\") (eq $property.required true) }}validate:\"required\" {{ end }}{{ end }}{{ template \"dataTypeTagsTemplate\" $ }}:\"{{ $property.value }}{{ if eq $property.required false}},omitempty{{ end }}\"`"

const responseTags = "{{ if eq $.type \"JSON\" }}`json:\"{{ $property.value }}{{if eq $property.required false}},omitempty{{ end }}\"`{{ end }}"

// blocks

var defineTemplates = inputStructTemplate + " " + responseStructTemplate + " " + dataTypeTagsTemplate

const dataTypeTagsTemplate = "{{ define \"dataTypeTagsTemplate\" }}{{ if eq .type \"URLEncoded\" }}form{{ else if eq .type \"FormData\" }}mapstructure{{ else if eq .type \"JSON\" }}json{{ end }}{{ end }}"

var inputStructTemplate = structTemplate("inputStructTemplate", inputTags)
var responseStructTemplate = structTemplate("responseStructTemplate", responseTags)

func structTemplate(templateName string, tags string) string {
	return strings.NewReplacer(
		"{templateName}", templateName,
		"{tags}", tags,
	).Replace(`{{ define "{templateName}" }} {{ if .documentation }} // {{ .name }} {{ .documentation.description }}
{{ end }} type {{ .name }} struct { {{range $index, $property := .properties }}
	{{ $property.name }} {{ if eq $property.required false }}*{{ end }}{{ $property.type }} {tags} {{end}}
} {{ end }}`)
}
